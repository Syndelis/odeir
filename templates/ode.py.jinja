import argparse, contextlib, sys, os
import scipy
import numpy as np

def writer(filename: str | None):
    if filename:
        return open(filename, 'w')
    else:
        return sys.stdout

def initial_values() -> np.ndarray:
    {% for arg in populations -%}
        {{- arg.name }}_0 = {{ arg.value }}
    {% endfor -%}

    return np.array((
        {% for arg in populations -%}
            {{- arg.name }}_0,
        {% endfor -%}
    ))


def constants() -> list:
    {% for constant in constants -%}
        {{- constant.name }} = {{ constant.value }}
    {% endfor -%}

    return [
        {% for constant in constants -%}
            {{- constant.name }},
        {% endfor -%}
    ]


def system(t: np.float64, y: np.ndarray, *constants) -> np.ndarray:
    # populations
    {% for arg in populations -%}
        {{- arg.name }}, {%- endfor %} = y

    # constants
    {%- if constants %}
    {% for arg in constants -%}
    {{- arg.name }},
{%- endfor %} = constants
    {% endif -%}

{%- macro display_composite(arg) %}
    {%- for comp in arg.composition -%}
        {%- if comp.contribution|trim != '+' -%} {{ comp.contribution }} {% endif -%}
        {%- if comp.value is defined -%} {{ comp.value }}
        {%- else -%}
            {%- set a = model.arguments[comp.name] -%}
            {%- if a.value is defined -%} {{- a.name }}
            {%- else -%} ({{- display_composite(a) -}})
            {%- endif -%}
        {%- endif -%}
        {%- if not loop.last %} {{ arg.operation }} {% endif -%}
    {%- endfor %} {% endmacro -%}

{% for pop in populations %}
    {%- set comp = model.arguments[equations[pop.name].argument] %}
    d{{ pop.name }}_dt = {{ display_composite(comp) }}
{%- endfor %}

    return np.array([
    {%- for arg in populations -%}
            d{{ arg.name }}_dt {%- if not loop.last %}, {%- endif -%} {% endfor %}])


def simulation_output_to_csv(sim_steps, simulation_output, write_to) -> str:
    if not simulation_output.success:
        print(simulation_output.message)
        return

    populatio_values_per_dt = simulation_output.y.T

    write_to.write("t,{% for arg in populations %}{{ arg.name }}{% if not loop.last %},{% endif %}{% endfor %}\n")

    for dt, y in zip(sim_steps, populatio_values_per_dt):
        write_to.write(f"{dt},")
        write_to.write(",".join(f"{val:.4f}" for val in y))
        write_to.write("\n")


def simulate(output_to, st=0, tf=10, dt=0.1):
    sim_steps = np.arange(st, tf + dt, dt)

    simulation_output = scipy.integrate.solve_ivp(
        fun=system,
        t_span=(0, tf + dt),
        y0=initial_values(),
        args=constants(),
        t_eval=sim_steps,
    )

    with writer(output_to) as f:
        simulation_output_to_csv(sim_steps, simulation_output, f)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument("--st", type=float, default=0)
    parser.add_argument("--tf", type=float, default=10)
    parser.add_argument("--dt", type=float, default=0.1)
    parser.add_argument("--output-file", default=None)

    args = parser.parse_args()

    if args.output_file:
        dirs = os.path.dirname(args.output_file)

        if dirs:
            os.makedirs(dirs, exist_ok=True)

    simulate(args.output_file)
